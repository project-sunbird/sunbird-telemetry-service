# This is the main configuration file for the application.
# https://www.playframework.com/documentation/latest/ConfigFile
# ~~~~~
## Secret key
# http://www.playframework.com/documentation/latest/ApplicationSecret
# ~~~~~
#play.crypto.secret = "changeme"


## Internationalisation
# https://www.playframework.com/documentation/latest/JavaI18N
# ~~~~~
play.i18n {
  # The application languages
  langs = [ "en" ]
}

## Play HTTP settings
# ~~~~~
play.http {
  ## Router
  # https://www.playframework.com/documentation/latest/JavaRouting
  # https://www.playframework.com/documentation/latest/ScalaRouting
  # ~~~~~
  # Define the Router object to use for this application.
  # This router will be looked up first when the application is starting up,
  # so make sure this is the entry point.
  # Furthermore, it's assumed your route file is named properly.
  # So for an application router like `my.application.Router`,
  # you may need to define a router file `conf/my.application.routes`.
  # Default to Routes in the root package (aka "apps" folder) (and conf/routes)
  #router = my.application.Router
  port=9090

}

## Netty Provider
# ~~~~~
play.server.netty {
  # If you run Play on Linux, you can use Netty's native socket transport
  # for higher performance with less garbage.
  #transport = "native"
}

## WS (HTTP Client)
# ~~~~~
libraryDependencies += javaWs 

## Cache
# https://www.playframework.com/documentation/latest/JavaCache
# https://www.playframework.com/documentation/latest/ScalaCache
# ~~~~~
# Play comes with an integrated cache API that can reduce the operational
# overhead of repeated requests. You must enable this by adding to build.sbt:
#
libraryDependencies += cache
#
play.cache {
  # If you want to bind several caches, you can bind the individually
  #bindCaches = ["db-cache", "user-cache", "session-cache"]
}

# Logger
# ~~~~~
# You can also configure logback (http://logback.qos.ch/),
# by providing an application-logger.xml file in the conf directory.

# Root logger:
#logger.root=ERROR

# Logger used by the framework:
#logger.play=INFO

# Logger provided to your application:
#logger.application=DEBUG

# APP Specific config
# ~~~~~
# Application specific configurations can be provided here
application.global=util.Global

SunbirdMWSystem {
  akka {
    actor {
      provider = "akka.actor.LocalActorRefProvider"
      serializers {
        java = "akka.serialization.JavaSerializer"
      }
      serialization-bindings {
        "org.sunbird.common.request.Request" = java
        "org.sunbird.common.models.response.Response" = java
      }
      deployment {

        /RequestRouter
          {
            router = smallest-mailbox-pool
            nr-of-instances = 4
          }
        /BackgroundRequestRouter
          {
            router = smallest-mailbox-pool
            nr-of-instances = 1
          }
        "/RequestRouter/*/TelemetryManagerActor"
          {
            router = smallest-mailbox-pool
            nr-of-instances = 4
          }
        "/RequestRouter/*/KafkaTelemetryDispatcher"
          {
            router = smallest-mailbox-pool
            nr-of-instances = 4
          }
      }
    }
    remote {
      maximum-payload-bytes = 30000000 bytes
      netty.tcp {
        port = 8088
        message-frame-size =  30000000b
        send-buffer-size =  30000000b
        receive-buffer-size =  30000000b
        maximum-frame-size = 30000000b
      }
    }
  }
}


play.http.parser.maxMemoryBuffer=1024K
play.http.filters=util.Filters